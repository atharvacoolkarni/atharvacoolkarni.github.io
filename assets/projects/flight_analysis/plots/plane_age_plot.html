<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Total Delay mean by year of manufacture</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #000000;
      --chart-bg: #ffffff;
    }

    body {
      font-family: "Segoe UI", sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--bg-color);
      color: var(--text-color);
      transition: background 0.3s, color 0.3s;
    }

    body[data-theme="dark"],
    html[data-theme="dark"] {
      --bg-color: #000000;
      --text-color: #ffffff;
      --chart-bg: #000000;
    }

    .chart-container {
      position: relative;
      margin: 0 auto;
      width: 900px;
      height: 500px;
      background-color: var(--chart-bg);
      transition: background-color 0.3s;
      overflow: hidden;
    }

    canvas {
      display: block;
      margin: 0;
      padding: 0;
      background: transparent;
    }
  </style>
</head>
<body>
  <div class="chart-container">
    <canvas id="myChart" width="900" height="500"></canvas>
  </div>

  <script>
    let chart;
    let rawData;

    const COLORS = {
      light: {
        "1956-1979": { base: "#17a2b8", hover: "#138496" },
        "1980-2007": { base: "#dc3545", hover: "#a71d2a" }
      },
      dark: {
        "1956-1979": { base: "#4fc3f7", hover: "#039be5" },
        "1980-2007": { base: "#fbc02d", hover: "#f57f17" }
      }
    };

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function isDarkMode() {
      // Check parent frame first if we're in an iframe
      try {
        if (window.parent && window.parent !== window) {
          const parentDoc = window.parent.document;
          if (parentDoc.documentElement.getAttribute('data-theme') === 'dark') return true;
          if (parentDoc.documentElement.getAttribute('data-theme') === 'light') return false;
          if (parentDoc.body.getAttribute('data-theme') === 'dark') return true;
          if (parentDoc.body.getAttribute('data-theme') === 'light') return false;
          if (parentDoc.documentElement.classList.contains('dark') || parentDoc.body.classList.contains('dark')) return true;
          if (window.parent.localStorage) {
            if (window.parent.localStorage.getItem('theme') === 'dark') return true;
            if (window.parent.localStorage.getItem('theme') === 'light') return false;
          }
        }
      } catch (e) {
        // Cross-origin restriction, fall back to local checks
      }
      
      // Detect dark mode from local context
      if (localStorage.getItem('theme') === 'dark') return true;
      if (localStorage.getItem('theme') === 'light') return false;
      if (document.documentElement.getAttribute('data-theme') === 'dark') return true;
      if (document.documentElement.getAttribute('data-theme') === 'light') return false;
      if (document.body.getAttribute('data-theme') === 'dark') return true;
      if (document.body.getAttribute('data-theme') === 'light') return false;
      if (document.documentElement.classList.contains('dark') || document.body.classList.contains('dark')) return true;
      return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    }

    function makeDatasets(raw, dark=false) {
      const theme = dark ? COLORS.dark : COLORS.light;
      return Object.keys(theme).flatMap(key => {
        const g = theme[key];
        const d = raw[key];
        if (!d) return [];

        const points = d.x.map((x,i) => ({
          x: Number(x),
          y: Number(d.y[i]),
          fit: Number(d.fit[i]),
          ci_low: Number(d.ci_low[i]),
          ci_high: Number(d.ci_high[i])
        })).sort((a,b) => a.x - b.x);

        const xs = points.map(p => p.x);
        const ys = points.map(p => p.y);
        const fits = points.map(p => p.fit);
        const ci_low = points.map(p => p.ci_low);
        const ci_high = points.map(p => p.ci_high);

        return [
          {
            label: key,
            data: xs.map((x,i) => ({x: x, y: ys[i]})),
            backgroundColor: g.base,
            borderColor: g.base,
            pointRadius: 4,
            pointHoverBackgroundColor: g.hover,
            pointHoverBorderColor: g.hover,
            showLine: false,
            order: 3,
            _baseColor: g.base,
            _hoverColor: g.hover
          },
          {
            label: `${key} fit`,
            data: xs.map((x,i) => ({x: x, y: fits[i]})),
            borderColor: g.base,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 0,
            pointHitRadius: 0,
            fill: false,
            tension: 0,
            order: 4
          },
          {
            label: `${key} CI lower`,
            data: xs.map((x,i) => ({x: x, y: ci_low[i]})),
            borderColor: 'transparent',
            backgroundColor: hexToRgba(g.base, 0.15),
            pointRadius: 0,
            borderWidth: 0,
            fill: '+1',
            tension: 0,
            order: 1
          },
          {
            label: `${key} CI upper`,
            data: xs.map((x,i) => ({x: x, y: ci_high[i]})),
            borderColor: 'transparent',
            backgroundColor: hexToRgba(g.base, 0.15),
            pointRadius: 0,
            borderWidth: 0,
            fill: false,
            tension: 0,
            order: 2
          }
        ];
      });
    }

    function applyTheme(dark) {
      if (!chart || !rawData) return;

      document.documentElement.style.setProperty('--bg-color', dark ? '#000000' : '#ffffff');
      document.documentElement.style.setProperty('--text-color', dark ? '#ffffff' : '#000000');
      document.documentElement.style.setProperty('--chart-bg', dark ? '#000000' : '#ffffff');

      chart.options.plugins.title.color = dark ? '#ffffff' : '#000000';
      chart.options.plugins.legend.labels.color = dark ? '#ffffff' : '#000000';
      chart.options.plugins.legend.labels.usePointStyle = false;
      chart.options.scales.x.ticks.color = dark ? '#ffffff' : '#000000';
      chart.options.scales.y.ticks.color = dark ? '#ffffff' : '#000000';
      chart.options.scales.x.title.color = dark ? '#ffffff' : '#000000';
      chart.options.scales.y.title.color = dark ? '#ffffff' : '#000000';
      chart.options.scales.x.grid.color = dark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';
      chart.options.scales.y.grid.color = dark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';
      chart.options.plugins.tooltip.backgroundColor = dark ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.8)';
      chart.options.plugins.tooltip.titleColor = dark ? '#ffffff' : '#000000';
      chart.options.plugins.tooltip.bodyColor = dark ? '#ffffff' : '#000000';
      chart.options.plugins.tooltip.borderColor = dark ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)';

      // Recreate datasets for current theme
      chart.data.datasets = makeDatasets(rawData, dark);
      chart.update('none');
    }

    fetch('regression_data.json')
      .then(r => r.json())
      .then(raw => {
        rawData = raw;
        const ctx = document.getElementById('myChart').getContext('2d');
        const darkMode = isDarkMode();

        chart = new Chart(ctx, {
          type: 'line',
          data: { datasets: makeDatasets(raw, darkMode) },
          options: {
            responsive: false,
            maintainAspectRatio: false,
            animation: false,
            plugins: {
              title: {
                display: true,
                text: 'Total Delay mean by year of manufacture',
                font: { size: 20 },
                color: darkMode ? '#ffffff' : '#000000'
              },
              tooltip: {
                callbacks: {
                  title: (ctx) => ctx[0].parsed.x.toFixed(0),
                  label: (ctx) => {
                    const lbl = ctx.dataset.label || '';
                    if (lbl.includes('fit') || lbl.includes('CI')) return null;
                    return `Total Delay: ${ctx.parsed.y.toFixed(1)}`;
                  }
                },
                filter: (ctx) => !(ctx.dataset.label.includes('fit') || ctx.dataset.label.includes('CI')),
                backgroundColor: darkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.8)',
                titleColor: darkMode ? '#ffffff' : '#000000',
                bodyColor: darkMode ? '#ffffff' : '#000000',
                borderColor: darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)',
                borderWidth: 1
              },
              legend: {
                labels: {
                  color: darkMode ? '#ffffff' : '#000000',
                  usePointStyle: false,
                  filter: (item) => !(item.text.includes('fit') || item.text.includes('CI'))
                },
                onClick: (e, legendItem) => {
                  const groupKey = legendItem.text;
                  chart.data.datasets.forEach((ds, i) => {
                    if (
                      ds.label === groupKey ||
                      ds.label === `${groupKey} fit` ||
                      ds.label === `${groupKey} CI lower` ||
                      ds.label === `${groupKey} CI upper`
                    ) {
                      chart.setDatasetVisibility(i, !chart.isDatasetVisible(i));
                    }
                  });
                  chart.update();
                }
              }
            },
            scales: {
              x: {
                type: 'linear',
                title: { display: true, text: 'Year', color: darkMode ? '#ffffff' : '#000000' },
                ticks: { precision: 0, color: darkMode ? '#ffffff' : '#000000', callback: (value) => value.toString() },
                grid: { color: darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)' }
              },
              y: {
                title: { display: true, text: 'Mean Total Delay', color: darkMode ? '#ffffff' : '#000000' },
                ticks: { color: darkMode ? '#ffffff' : '#000000' },
                grid: { color: darkMode ? 'rgba(255,255,255,0.2)' : 'rgba(0,0,0,0.1)' }
              }
            }
          }
        });

        const observer = new MutationObserver(() => applyTheme(isDarkMode()));
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['class','data-theme'] });
        observer.observe(document.body, { attributes: true, attributeFilter: ['class','data-theme'] });
        
        // Also observe parent frame if available
        try {
          if (window.parent && window.parent !== window) {
            const parentDoc = window.parent.document;
            observer.observe(parentDoc.documentElement, { attributes: true, attributeFilter: ['class','data-theme'] });
            observer.observe(parentDoc.body, { attributes: true, attributeFilter: ['class','data-theme'] });
            window.parent.addEventListener('storage', () => applyTheme(isDarkMode()));
          }
        } catch (e) {
          // Cross-origin restriction, can't observe parent
        }
        
        window.addEventListener('storage', () => applyTheme(isDarkMode()));
        if (window.matchMedia) {
          window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => applyTheme(isDarkMode()));
        }
      })
      .catch(err => console.error('Error loading regression_data.json:', err));
  </script>
</body>
</html>
